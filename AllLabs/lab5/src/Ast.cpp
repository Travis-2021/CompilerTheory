#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <string>
#include "Type.h"
#include <cassert>
#include<list>

extern FILE *yyout;
int Node::counter = 0;
IRBuilder* Node::builder = nullptr;

Type* nowFucnRetType;

Node::Node()
{
    seq = counter++;
}

//回填
//遍历list中的所有指令，将条件跳转指令的trueBranch设置为bb；将无条件跳转指令的branch设置为bb
void Node::backPatch(std::vector<Instruction*> &list, BasicBlock*bb)
{
    for(auto &inst:list)
    {
        if(inst->isCond())
            dynamic_cast<CondBrInstruction*>(inst)->setTrueBranch(bb);
        else if(inst->isUncond())
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);
    }
}

//合并
//把list2中的指令放在list1后面，返回合并后的指令集
std::vector<Instruction*> Node::merge(std::vector<Instruction*> &list1, std::vector<Instruction*> &list2)
{
    std::vector<Instruction*> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}


//----------genCode----------

void Ast::genCode(Unit *unit)
{
    // std::cout<<"Ast"<<std::endl;
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    if(root!=nullptr){
       root->genCode(); 
    }
}

void BinaryExpr::genCode()
{
    // std::cout<<"BinaryExpr"<<std::endl;

    BasicBlock *bb = builder->getInsertBB();
    Function *func = bb->getParent();

    //逻辑运算表达式
    if (op == AND)
    {
        BasicBlock *trueBB = new BasicBlock(func);  // if the result of lhs is true, jump to the trueBB.
        expr1->genCode();

        bb = builder->getInsertBB();
        BasicBlock *truebb, *falsebb, *tempbb;
        //temp basic blocks
        truebb = new BasicBlock(func);
        falsebb = new BasicBlock(func);
        tempbb = new BasicBlock(func);
        expr1->trueList().push_back(new CondBrInstruction(truebb, tempbb, expr1->getOperand(), bb));

        //在tempbb中设置跳转块为falsebb
        expr1->falseList().push_back(new UncondBrInstruction(falsebb, tempbb));


        backPatch(expr1->trueList(), trueBB);
        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        expr2->genCode();
        dst=expr2->getOperand();

        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
    }
    else if(op == OR)
    {
        BasicBlock *falseBB = new BasicBlock(func);
        expr1->genCode();
        bb = builder->getInsertBB();
        BasicBlock *truebb, *falsebb, *tempbb;

        //temp basic blocks
        truebb = new BasicBlock(func);
        falsebb = new BasicBlock(func);
        tempbb = new BasicBlock(func);
        expr1->trueList().push_back(new CondBrInstruction(truebb, tempbb, expr1->getOperand(), bb));
        expr1->falseList().push_back(new UncondBrInstruction(falsebb, tempbb));

         
        backPatch(expr1->falseList(), falseBB);
        builder->setInsertBB(falseBB);   
        
        expr2->genCode();
        dst=expr2->getOperand();
        false_list=expr2->falseList();
        true_list=merge(expr1->trueList(),expr2->trueList());
    }

    //关系运算表达式
    else if(op >= GREAT && op <= NEQ)
    {
        if(expr1!=nullptr){
            expr1->genCode();
        }
        if(expr2!=nullptr){
            expr2->genCode();
        }
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch(op)
        {
        case GREAT:
            opcode=CmpInstruction::G;
            break;
        case LESS:
            opcode=CmpInstruction::L;
            break;
        case GREATEQ:
            opcode=CmpInstruction::GE;
            break;
        case LESSEQ:
            opcode=CmpInstruction::LE;
            break;
        case EQ:
            opcode=CmpInstruction::E;
            break;
        case NEQ:
            opcode=CmpInstruction::NE;
            break;
        }
        new CmpInstruction(opcode, dst, src1, src2, bb);

    }
    //算术运算表达式
    else if(op >= ADD && op <= MOD)
    {
        if(expr1!=nullptr){
            expr1->genCode();
        }
        if(expr2!=nullptr){
            expr2->genCode();
        }
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
        case MOD:
            opcode = BinaryInstruction::MOD;
            break;
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
    }
}

void UnaryExpr::genCode()
{
    // std::cout<<"UnaryExpr"<<std::endl;

    BasicBlock* bb = builder->getInsertBB();
    if(expr!=nullptr){
            expr->genCode();
    }

    //如果是NOT，则相当于二元运算中与1异或
    if(op==NOT){
        Operand* src1 = expr->getOperand();
        Operand* src2 = new Operand(new ConstantSymbolEntry(dst->getType(),1));
        new BinaryInstruction(BinaryInstruction::XOR, dst, src1, src2, bb);
    }
    //如果是SUB，则相当于二元运算中0-expr
    else if(op==SUB){
        Operand* src1 = new Operand(new ConstantSymbolEntry(dst->getType(),0));
        Operand* src2 = expr->getOperand();
        new BinaryInstruction(BinaryInstruction::SUB, dst, src1, src2, bb);
    }
}

void Constant::genCode()
{
    // we don't need to generate code.
    // std::cout<<"Constant"<<std::endl;
}

void Id::genCode()
{
    // std::cout<<"Id"<<std::endl;

    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(se)->getAddr();
    new LoadInstruction(dst, addr, bb);
}

void TypeCastExpr::genCode()
{
    // std::cout<<"TypeCastExpr"<<std::endl;

    if(expr!=nullptr){
        expr->genCode();
        BasicBlock* bb=builder->getInsertBB();
        //int2bool 目标类型为bool但expr类型为int
        if(se->getType()->isBool() && expr->getSymPtr()->getType()->isInt32()){
            new CmpInstruction(CmpInstruction::NE, dst, expr->getOperand(),
                    new Operand(new ConstantSymbolEntry(TypeSystem::intType, 0)),bb);
            fprintf(stderr,"Implicit conversion: int->bool\n");
        }

        //bool2int 目标类型为int但expr类型为bool
        if(se->getType()->isInt32() && expr->getSymPtr()->getType()->isBool()){
            new ExtInstruction(dst, expr->getOperand(), bb);
            fprintf(stderr,"Implicit conversion: bool->int\n");
        }
    }
}

void CompoundStmt::genCode()
{
    // std::cout<<"CompoundStmt"<<std::endl;

    if(stmt!=nullptr){
        stmt->genCode();
    }
}

void SeqNode::genCode()
{
    // std::cout<<"SeqNode"<<std::endl;

    if(stmt1!=nullptr){
        stmt1->genCode();
    }
    if(stmt2!=nullptr){
        stmt2->genCode();
    }
}

void DeclStmt::genCode()
{
    // std::cout<<"DeclStmt"<<std::endl;

    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    if(se->isGlobal())
    {
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);

        Instruction *globalVal;
        if (initVal != nullptr) {
            initVal->genCode();
            Operand *init = initVal->getOperand();
            globalVal = new GlobalValInstruction(se, init, false);
        } else {
            globalVal = new GlobalValInstruction(se, nullptr, false);
        }

        builder->getUnit()->insertInst(globalVal);

    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.

        if(initVal!=nullptr){
            BasicBlock* bb=builder->getInsertBB();
            initVal->genCode();
            Operand* src=initVal->getOperand();
            new StoreInstruction(addr, src, bb);
        }
    }
}

void ConstDecl::genCode()
{
    // std::cout<<"ConstDecl"<<std::endl;

    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    if(se->isGlobal())
    {
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);

        Instruction *globalVal;

        if (initVal != nullptr) {
            initVal->genCode();
            Operand *init = initVal->getOperand();
            globalVal = new GlobalValInstruction(se, init, true);
        } else {
            fprintf(stderr,"constant must be inited\n");
            assert(initVal!=nullptr);
        }

        builder->getUnit()->insertInst(globalVal);

    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.

        BasicBlock* bb=builder->getInsertBB();
        if(initVal!=nullptr){
            initVal->genCode();
        }
        Operand* src=initVal->getOperand();
        new StoreInstruction(addr, src, bb);
    }
}

void DefList::genCode()
{
    // std::cout<<"DefList"<<std::endl;

    if(def1!=nullptr){
        def1->genCode();
    }
    if(def2!=nullptr){
        def2->genCode();
    }
}

void IfStmt::genCode()
{
    Function *func;
    BasicBlock *then_bb, *end_bb,*bb;

    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
  
    cond->genCode();
    
    bb = builder->getInsertBB();
    BasicBlock *truebb, *falsebb, *tempbb;
    //temp basic block
    truebb = new BasicBlock(func);
    falsebb = new BasicBlock(func);
    tempbb = new BasicBlock(func);
     
    cond->trueList().push_back(new CondBrInstruction(truebb, tempbb, cond->getOperand(), bb));
    //在tempbb中设置跳转块为falsebb
    cond->falseList().push_back(new UncondBrInstruction(falsebb, tempbb));

    backPatch(cond->trueList(), then_bb);
    backPatch(cond->falseList(), end_bb);

    //生成then_bb中的指令
    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();

    //在then_bb插入一条跳到end_bb中的无条件跳转指令
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);
}

void IfElseStmt::genCode()
{
    Function* func;
    BasicBlock *then_bb, *else_bb, *end_bb,*bb ;
    // bb = builder->getInsertBB();
    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    else_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    if(((IntType*)(cond->getSymPtr()->getType()))->getSize()!=1){
       
        cond=new TypeCastExpr(cond,TypeSystem::boolType);
        
    }
    cond->genCode();
    
    bb = builder->getInsertBB();
    
    BasicBlock *truebb, *falsebb, *tempbb;
    //temp basic blocks
    truebb = new BasicBlock(func);
    falsebb = new BasicBlock(func);
    tempbb = new BasicBlock(func);
    
    cond->trueList().push_back(new CondBrInstruction(truebb, tempbb, cond->getOperand(), bb));
    //在tempbb中设置跳转块为falsebb
    cond->falseList().push_back(new UncondBrInstruction(falsebb, tempbb));
    backPatch(cond->trueList(), then_bb);
    backPatch(cond->falseList(), else_bb);

    // new CondBrInstruction(then_bb,else_bb,IfElsecond,bb);

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(else_bb);
    elseStmt->genCode();
    else_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, else_bb);

    builder->setInsertBB(end_bb);

}

void WhileStmt::genCode()
{
    // std::cout<<"WhileStmt"<<std::endl;

    Function* func;
    BasicBlock* bb,*cond_bb,*stmt_bb,*end_bb;

    func = builder->getInsertBB()->getParent();
    cond_bb=new BasicBlock(func);
    stmt_bb=new BasicBlock(func);
    end_bb=new BasicBlock(func);

    bb = builder->getInsertBB();
    new UncondBrInstruction(cond_bb,bb);

    builder->setInsertBB(cond_bb);

    if(((IntType*)(cond->getSymPtr()->getType()))->getSize()!=1){
        cond=new TypeCastExpr(cond,TypeSystem::boolType);
    }

    cond->genCode();
    bb = builder->getInsertBB();
    BasicBlock *truebb, *falsebb, *tempbb;
    //temp basic blocks
    truebb = new BasicBlock(func);
    falsebb = new BasicBlock(func);
    tempbb = new BasicBlock(func);
    cond->trueList().push_back(new CondBrInstruction(truebb, tempbb, cond->getOperand(), bb));
    //在tempbb中设置跳转块为falsebb
    cond->falseList().push_back(new UncondBrInstruction(falsebb, tempbb));
    backPatch(cond->trueList(),stmt_bb);
    backPatch(cond->falseList(),end_bb);

    builder->setInsertBB(stmt_bb);
    loopBodyStmt->genCode();
    stmt_bb=builder->getInsertBB();
    new UncondBrInstruction(cond_bb,stmt_bb);

    builder->setInsertBB(end_bb);
}

void ReturnStmt::genCode()
{
    // std::cout<<"ReturnStmt"<<std::endl;

    BasicBlock* bb = builder->getInsertBB();
    Operand* src = nullptr;
    if(retValue!=nullptr){
        retValue->genCode();
        src = retValue->getOperand();
    }
    new RetInstruction(src, bb);
}

void AssignStmt::genCode()
{
    // std::cout<<"AssignStmt"<<std::endl;

    BasicBlock *bb = builder->getInsertBB();
    if(expr!=nullptr){
        expr->genCode();
    }
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(lval->getSymPtr())->getAddr();
    Operand *src = expr->getOperand();
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just store the result of the `expr` to the addr of the id.
     * If you want to implement array, you have to caculate the address first and then store the result into it.
     */
    new StoreInstruction(addr, src, bb);
}

void ExpStmt::genCode()
{
    // std::cout<<"ExpStmt"<<std::endl;

    if(expr!=nullptr){
        expr->genCode();
    }
}

void FuncRParams::genCode()
{
    // std::cout<<"FuncRParams"<<std::endl;

    if(params!=nullptr){
        params->genCode();
    }
    if(param!=nullptr){
        param->genCode();
    }
}

void FuncRParams::getOperands(std::vector<Operand*>&operands)
{
    params->getOperands(operands);
    param->getOperands(operands);
}

void FuncFParams::genCode()
{
    // std::cout<<"FuncFParams"<<std::endl;

    if(params!=nullptr){
        params->genCode();
    }
    if(param!=nullptr){
        param->genCode();
    }
}

void FuncFParams::getSymbolEntrys(std::vector<SymbolEntry*>&ses)
{
    params->getSymbolEntrys(ses);
    param->getSymbolEntrys(ses);
}

void FuncFParam::genCode()
{
    // std::cout<<"FuncFParam"<<std::endl;

    SymbolEntry* addr_se = new TemporarySymbolEntry(new PointerType(se->getType()),SymbolTable::getLabel());
    Operand* addr = new Operand(addr_se);
    Operand* src = new Operand(se);
    dynamic_cast<IdentifierSymbolEntry*>(se)->setAddr(addr);
    BasicBlock* bb = builder->getInsertBB()->getParent()->getEntry();
    Instruction* alloca = new AllocaInstruction(addr, se);
    bb->insertFront(alloca);
    new StoreInstruction(addr, src, bb);
}

void FunctionDef::genCode()
{
    // std::cout<<"FunctionDef"<<std::endl;

    Unit *unit = builder->getUnit();
    std::vector<SymbolEntry*> param_syms;
    if(params!=nullptr){
        params->getSymbolEntrys(param_syms);
    }
    Function *func = new Function(unit, se, param_syms);
    BasicBlock *entry = func->getEntry();
    // set the insert point to the entry basicblock of this function.
    builder->setInsertBB(entry);

    if(params!=nullptr){
        params->genCode();
    }
    if(stmt!=nullptr){
        stmt->genCode();
    }

    /**
     * Construct control flow graph. You need do set successors and predecessors for each basic block.
     * Todo
    */
   for(auto &bb:func->getBlockList()){
       Instruction* inst = bb->rbegin();
       if(inst->isCond()){
           CondBrInstruction* br = dynamic_cast<CondBrInstruction*>(inst);
           BasicBlock* succ1 = br->getTrueBranch();
           BasicBlock* succ2 = br->getFalseBranch();
           bb->addSucc(succ1);
           bb->addSucc(succ2);
           succ1->addPred(bb);
           succ2->addPred(bb);
       }
       else if(inst->isUncond()){
           UncondBrInstruction* br = dynamic_cast<UncondBrInstruction*>(inst);
           BasicBlock* succ = br->getBranch();
           bb->addSucc(succ);
           succ->addPred(bb);
       }
   }
}


void FuncCallExpr::genCode()
{
    // std::cout<<"FuncCallExpr"<<std::endl;

    std::vector<Operand*>p;
    if(params!=nullptr){
        params->genCode();
        params->getOperands(p);
    }
    BasicBlock* bb = builder->getInsertBB();
    if(((FunctionType*)(t->getType()))->getRetType()==TypeSystem::voidType){
        dst=nullptr;
    }
    new CallInstruction(dst, p, t, bb);
}

void EmptyStmt::genCode()
{
    //do nothing
}


//----------typeCheck----------

void Ast::typeCheck()
{
    if(root != nullptr)
        root->typeCheck();
}

void UnaryExpr::typeCheck()
{
    expr->typeCheck();
    Type* type=expr->getSymPtr()->getType();

    //void类型参与一元运算
    if(type==TypeSystem::voidType){
        fprintf(stderr, "Void type is involved in compution\n");
    }
    //操作符为非，表达式为int型，需要进行类型转换
    if(op==NOT && type->isInt32()){
        expr=new TypeCastExpr(expr,TypeSystem::boolType);
        se->setType(TypeSystem::boolType);
    }
    //操作符为负，表达式为bool型，需要进行类型转换
    if(op==SUB && type->isBool()){
        expr=new TypeCastExpr(expr,TypeSystem::intType);
        se->setType(TypeSystem::intType);
    }
    if(op==ADD){
        dst=expr->getOperand();
        se->setType(TypeSystem::intType);
    }
}

void BinaryExpr::typeCheck()
{
    expr1->typeCheck();
    expr2->typeCheck();

    Type* type1=expr1->getSymPtr()->getType();
    Type* type2=expr2->getSymPtr()->getType();

    if(type1==TypeSystem::voidType || type2==TypeSystem::voidType){
        fprintf(stderr, "Void type is involved in compution\n");
        exit(-1);
    }
    
    //如果操作符为与、或，则两个表达式都应该是bool型
    if(op==AND||op==OR){
        if(type1->isInt32()){
            expr1=new TypeCastExpr(expr1,TypeSystem::boolType);
        }
        if(type2->isInt32()){
            expr2=new TypeCastExpr(expr2,TypeSystem::boolType);
        }
        se->setType(TypeSystem::boolType);
    }

    //关系表达式
    else if(op >= GREAT && op <= NEQ){
        if(type1->isBool()){
            expr1=new TypeCastExpr(expr1,TypeSystem::intType);
        }
        if(type2->isBool()){
            expr2=new TypeCastExpr(expr2,TypeSystem::intType);
        }
        se->setType(TypeSystem::boolType);
    }

    //算术表达式
    else if(op >= ADD && op <= MOD){
        if(type1->isBool()){
            expr1=new TypeCastExpr(expr1,TypeSystem::intType);
        }
        if(type2->isBool()){
            expr2=new TypeCastExpr(expr2,TypeSystem::intType);
        }
        se->setType(TypeSystem::intType);
    }
}

void Constant::typeCheck()
{
    // Todo
}

void Id::typeCheck()
{
    // Todo
}

void TypeCastExpr::typeCheck()
{
    if(expr!=nullptr){
        expr->typeCheck();
    }
}

void CompoundStmt::typeCheck()
{
    if(stmt!=nullptr){
        stmt->typeCheck();
    }
}

void SeqNode::typeCheck()
{
    if(stmt1!=nullptr){
        stmt1->typeCheck();
    }
    if(stmt2!=nullptr){
        stmt2->typeCheck();
    }
}

void DeclStmt::typeCheck()
{
    // //根据符号表中的install函数，重复声明会覆盖？？？
    // //已修改符号表install函数
    // IdentifierSymbolEntry* se = (IdentifierSymbolEntry*)(id->getSymPtr());

}

void ConstDecl::typeCheck()
{
    //?????????
}

void DefList::typeCheck()
{
    if(def1!=nullptr){
        def1->typeCheck();
    }
    if(def2!=nullptr){
        def2->typeCheck();
    }
}

void IfStmt::typeCheck()
{
    if(cond!=nullptr){
        cond->typeCheck();
        if(!cond->getSymPtr()->getType()->isBool()){
            cond=new TypeCastExpr(cond,TypeSystem::boolType);
        }
    }

    if(thenStmt!=nullptr){
        thenStmt->typeCheck();
    }
}
void IfElseStmt::typeCheck()
{
    if(cond!=nullptr){
        cond->typeCheck();
        if(!cond->getSymPtr()->getType()->isBool()){
            cond=new TypeCastExpr(cond,TypeSystem::boolType);
        }
    }
    if(thenStmt!=nullptr){
        thenStmt->typeCheck();
    }
    if(elseStmt!=nullptr){
        elseStmt->typeCheck();
    }
}

void WhileStmt::typeCheck()
{
    if(cond!=nullptr){
        cond->typeCheck();
        if(!cond->getSymPtr()->getType()->isBool()){
            cond=new TypeCastExpr(cond,TypeSystem::boolType);
        }
    }

    if(loopBodyStmt!=nullptr){
        loopBodyStmt->typeCheck();
    }
}

void ReturnStmt::typeCheck()
{
    //return 语句操作数和函数声明的返回值类型是否匹配
    if(retValue!=nullptr){
        Type* retType=retValue->getSymPtr()->getType();
        if(retType!=TypeSystem::voidType && nowFucnRetType==TypeSystem::voidType){
            fprintf(stderr, "retType should be void\n");
        }
        if(retType==TypeSystem::voidType && nowFucnRetType!=TypeSystem::voidType){
            fprintf(stderr, "retType should be non_void\n");
        }
        if(retType==TypeSystem::boolType && nowFucnRetType==TypeSystem::intType){
            retValue=new TypeCastExpr(retValue,TypeSystem::intType);
        }
        retValue->typeCheck();
    }
}

void AssignStmt::typeCheck()
{
    if(lval!=nullptr){
        lval->typeCheck();
    }
    if(expr!=nullptr){
        expr->typeCheck();
    }
    //用bool型为int型赋值，或用int型为bool型赋值，需要进行类型转换
    Type* lType=lval->getSymPtr()->getType();
    Type* rType=expr->getSymPtr()->getType();

    if(lType==TypeSystem::intType && rType==TypeSystem::boolType){
        expr=new TypeCastExpr(expr,TypeSystem::intType);
    }
    if(lType==TypeSystem::boolType && rType==TypeSystem::intType){
        expr=new TypeCastExpr(expr,TypeSystem::boolType);
    }
}

void ExpStmt::typeCheck()
{
    if(expr!=nullptr){
        expr->typeCheck();
    }
}

void FuncRParams::typeCheck()
{
    if(params!=nullptr){
        params->typeCheck();
    }
    if(param!=nullptr){
        param->typeCheck();
    }
}

void FuncFParams::typeCheck()
{
    if(params!=nullptr){
        params->typeCheck();
    }
    if(param!=nullptr){
        param->typeCheck();
    }
}

void FuncFParam::typeCheck()
{
    //do nothing
}

void FunctionDef::typeCheck()
{
    nowFucnRetType=((FunctionType*)(se->getType()))->getRetType();

    if(params!=nullptr){
        params->typeCheck();
    }
    if(stmt!=nullptr){
        stmt->typeCheck();
    }
}

void FuncCallExpr::typeCheck() {
    // 函数调用时形参及实参类型或数目的不一致

    if (params != nullptr) {
        params->typeCheck();
    }

    //根据函数名查找到函数符号表项，获得函数形参类型列表
    SymbolEntry *se = identifiers->lookup(t->toStr().substr(1));
    FunctionType *funcType = dynamic_cast<FunctionType *>(se->getType());
    auto paramsType = funcType->getParamsType();

    //获取函数实参操作数列表
    std::vector<Operand *> p;
    if (params != nullptr) {
        params->getOperands(p);
    }

    if (paramsType.size() != p.size()) {
        fprintf(stderr, "Number of parameters does not match\n");
        exit(-1);
    }

    for (int i = 0; i < (int)(p.size()); ++i) {
        if (paramsType[i]->getKind() != p[i]->getType()->getKind()) {
            fprintf(stderr, "Type of parameters does not match\n");
            exit(-1);
        }
    }
}

void EmptyStmt::typeCheck()
{
    //do nothing
}


//---------output------------

void Ast::output()
{
    fprintf(yyout, "program\n");
    if(root != nullptr)
        root->output(4);
}

void BinaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case MUL:
            op_str = "mul";
            break;
        case DIV:
            op_str = "div";
            break;
        case MOD:
            op_str = "mod";
            break;
        case AND:
            op_str = "and";
            break;
        case OR:
            op_str = "or";
            break;
        case GREAT:
            op_str = "great";
            break;
        case LESS:
            op_str = "less";
            break;
        case GREATEQ:
            op_str = "greateq";
            break;
        case LESSEQ:
            op_str = "lesseq";
            break;
        case EQ:
            op_str = "eq";
            break;
        case NEQ:
            op_str = "neq";
            break;
    }
    fprintf(yyout, "%*cBinaryExpr\top: %s\n", level, ' ', op_str.c_str());
    if(expr1!=nullptr)
        expr1->output(level + 4);
    if(expr2!=nullptr)
        expr2->output(level + 4);
}

void UnaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case NOT:
            op_str = "not";
            break;
    }
    fprintf(yyout, "%*cUnaryExpr\top: %s\n", level, ' ', op_str.c_str());
    if(expr!=nullptr)
        expr->output(level + 4);
}


void Constant::output(int level)
{
    std::string type, value;
    type = se->getType()->toStr();
    value = se->toStr();
    fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

void Id::output(int level)
{
    std::string name, type;
    int scope;
    name = se->toStr();
    type = se->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(se)->getScope();
    fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
}

void TypeCastExpr::output(int level)
{
    //do nothing
}

void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    if(stmt!=nullptr)
        stmt->output(level + 4);
}

void SeqNode::output(int level)
{
    fprintf(yyout, "%*cSequence\n", level, ' ');
    if(stmt1!=nullptr)
        stmt1->output(level + 4);
    if(stmt2!=nullptr)
        stmt2->output(level + 4);
}

void DeclStmt::output(int level)
{
    fprintf(yyout, "%*cDeclStmt\n", level, ' ');
    if(id!=nullptr)
        id->output(level + 4);
}

void ConstDecl::output(int level)
{
    fprintf(yyout, "%*cConstDecl\n", level, ' ');
    if(id!=nullptr)
        id->output(level + 4);
    if(initVal!=nullptr)
        initVal->output(level + 4);
}

void DefList::output(int level)
{
    fprintf(yyout, "%*cDefList\n", level, ' ');
    if(def1!=nullptr)
        def1->output(level + 4);
    if(def2!=nullptr)
        def2->output(level + 4);
}

void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    if(cond!=nullptr)
        cond->output(level + 4);
    if(thenStmt!=nullptr)
        thenStmt->output(level + 4);
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    if(cond!=nullptr)
        cond->output(level + 4);
    if(thenStmt!=nullptr)
        thenStmt->output(level + 4);
    if(elseStmt!=nullptr)
        elseStmt->output(level + 4);
}

void WhileStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    if(cond!=nullptr)
        cond->output(level + 4);
    if(loopBodyStmt!=nullptr)
        loopBodyStmt->output(level + 4);
}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    if(retValue!=nullptr)
        retValue->output(level + 4);
}

void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    if(lval!=nullptr)
        lval->output(level + 4);
    if(expr!=nullptr)
        expr->output(level + 4);
}

void ExpStmt::output(int level)
{
    fprintf(yyout, "%*cExpStmt\n", level, ' ');
    if(expr!=nullptr)
        expr->output(level + 4);
}

void FunctionDef::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s\n", level, ' ', 
            name.c_str(), type.c_str());
    if(params!=nullptr)
        params->output(level + 4);
    if(stmt!=nullptr)
        stmt->output(level + 4);
}

void FuncCallExpr::output(int level)
{
    std::string name, type;
    name = t->toStr();
    type = t->getType()->toStr();
    fprintf(yyout, "%*cFuncCallExpr function name: %s, type: %s\n", level, ' ', 
            name.c_str(), type.c_str());
    if(params!=nullptr)
        params->output(level + 4);
}

void FuncRParams::output(int level)
{
    fprintf(yyout, "%*cFuncRParams\n", level, ' ');
    if(params!=nullptr)
        params->output(level + 4);
    if(param!=nullptr)
        param->output(level + 4);
}

void FuncFParams::output(int level)
{
    fprintf(yyout, "%*cFuncFParams\n", level, ' ');
    if(params!=nullptr)
        params->output(level + 4);
    if(param!=nullptr)
        param->output(level + 4);
}

void FuncFParam::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    fprintf(yyout, "%*cFuncFParam param name: %s, type: %s\n", level, ' ', 
            name.c_str(), type.c_str());
}

void EmptyStmt::output(int level)
{
    fprintf(yyout, "%*cEmptyStmt\n", level, ' ');
}